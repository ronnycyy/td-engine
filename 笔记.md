# 代办事项
1. 使用 rollup 打包  ✅2022-10-24
2. 绘制一个 Rect  ✅2022-10-24
3. 拾取这个 Rect:
  * 研究 fabirc 事件、触发 ✅2022-10-24
  * 在 tdEngine 中实现极简版 ✅2022-10-24
4. 绘制控制点  ✅2022-10-25
5. 移动


# fabric 的拾取方案 (个人认为非常烂!)
1. 获取鼠标点击的位置 p。
2. 遍历所有图形: 判断点击的这个位置是否在某一个图形中。
3. 如果有，返回该图形，如果没有，返回 null。
## 点是否在图形中
判断点是否在图形中，用的是[点射线法](https://juejin.cn/post/6844903834179878925),
需要从点沿着x轴作一条射线，检查该射线和图形的边的相交点数:
  如果是奇数: 点在射线内;
  如果是偶数: 点不在图形内;
## 时间复杂度
1. 首先`遍历`这一步就要 O(N) 了。
2. 然后判断`点是否在图形中`这一步，需要找到图形的边，然后找射线和边的交点，这些又要增加常数时间。
所以我认为，这个方案非常烂!


# 全新的拾取方案
1. 有两层canvas，一层`隐藏`(visibility: hidden)，一层`可见`，onMouseDown 事件监听在`可见层`。
2. 绘制图形时，在可见层和隐藏层都绘制一次，两者形状一模一样，但是隐藏图形`填充`满一个随机颜色，建立 Map 映射`随机颜色->图形对象`。
3. 在 onMouseDown 中获取点击位置的 e.clientX, e.clientY, 然后通过 hiddenCtx.getImageData(x,y,1,1).data 取得隐藏层该像素点的颜色。
通过 Map 查到是否有映射的图形:
  * 如果有，就`拾取`到了这个图形。
  * 如果没有，就代表该点没有图形。
## 时间复杂度
1. 从点击位置获取颜色 getImageData O(1)
2. 通过 Map 从颜色值获取图形 O(1)


# Retina屏
*目的*
获得更清晰的图像。
*背景*
放大倍数基于 window.devicePixelRatio 它告诉浏览器应使用多少屏幕实际像素来绘制单个 CSS 像素, 从而获得更清晰的图像。
*步骤*
1. 放大 canvas 的 width/height 为 2 倍，原来是`500*500`，现在是`1000*1000`。
2. 但是设置 canvas 的 style 为原始宽高, 也就是`500*500`, 意思就是在`500*500的画布(html坐标系)`上，画`1000*1000的坐标系`。
3. 上面设置完以后，由于绘制`20*20`的图形是基于`1000*1000的坐标系`，所以看起来是`10*10`, 会缩小了1倍。
4. 这时候就要用 ctx.scale(2,2)，使 x轴刻度乘以2, y轴刻度也乘以2, 这样图形就放大了1倍，`20*20`就等同于 html 坐标下的 `20*20`了

